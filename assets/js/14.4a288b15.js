(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{261:function(t,e,s){"use strict";s.r(e);var a=s(14),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"vue-源码学习"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-源码学习"}},[t._v("#")]),t._v(" Vue 源码学习")]),t._v(" "),s("blockquote",[s("p",[t._v("记录我学习 "),s("code",[t._v("Vue")]),t._v(" 源码的过程。")])]),t._v(" "),s("h2",{attrs:{id:"前提"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前提"}},[t._v("#")]),t._v(" 前提")]),t._v(" "),s("p",[t._v("看源码是有前提的，你需要对框架足够熟悉了再去看，大致可以分为如下几个问题。")]),t._v(" "),s("p",[s("strong",[s("code",[t._v("Vue")]),t._v(" 解决了什么问题?")])]),t._v(" "),s("ul",[s("li",[t._v("组件化")]),t._v(" "),s("li",[t._v("声明式渲染")]),t._v(" "),s("li",[t._v("MVVM")])]),t._v(" "),s("p",[s("strong",[s("code",[t._v("Vue")]),t._v(" 的设计思想是什么？")])]),t._v(" "),s("ul",[s("li",[t._v("响应式数据")])]),t._v(" "),s("p",[s("strong",[s("code",[t._v("Vue")]),t._v(" 有哪些主要的功能点？")])]),t._v(" "),s("ul",[s("li",[t._v("变化监测")]),t._v(" "),s("li",[t._v("模板编译")]),t._v(" "),s("li",[t._v("虚拟 DOM")])]),t._v(" "),s("h2",{attrs:{id:"准备"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#准备"}},[t._v("#")]),t._v(" 准备")]),t._v(" "),s("h3",{attrs:{id:"项目目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#项目目录"}},[t._v("#")]),t._v(" 项目目录")]),t._v(" "),s("p",[s("code",[t._v("Vue")]),t._v(" 的仓库采用了 monorepo 的方式，也就是所有相关的项目都在这个仓库中，我们熟悉的 "),s("code",[t._v("vue-template-compiler")]),t._v(" 就在其中，具体有哪些在 /package 中都可以看到，下面是一些主要的文件夹及其对应的功能：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("/vue\n  ├── /flow                                     # flow 的声明文件\n  ├── /packages                                 # 相关项目，如 vue-template-compiler\n  ├── /scripts                                  # 构建、发布相关的脚本\n  ├── /src\n        ├── /compiler                           # 模板编译\n        ├── /core                               # 核心代码\n                ├── /components                 # 全局内置组件，目前只包括 `keep-alive`\n                ├── /global-api                 # 定义 `Vue` 上的 API\n                ├── /instance                   # 定义 `Vue.prototype` 上的 API\n                ├── /observer                   # 响应式\n                ├── /util                       # core 文件夹下的工具函数\n                ├── /vdom                       # 虚拟 dom\n        ├── /platforms                          # 不同平台的支持\n                ├── /web\n                      ├── /compiler             # web 平台下，模板编译支持的属性和指令，如 `v-model`，`v-text` 等\n                      ├── /runtime              # web 平台下，运行时支持的属性和指令，如 `transition`,`style`, `v-model` 等\n                      ├── /server               # 服务端渲染\n                      ├── /util                 # web 平台下的工具含糊\n                      ├── entry-xxx.js          # 不同版本的入口文件，如包括运行时编译的 entry-runtime-with-compiler.js\n                ├── /weex\n      ├── /server                               # 服务端渲染\n      ├── /sfc                                  # .vue 文件解析\n      ├── /shared                               # 共享代码\n├── /test                                       # 测试用例\n├── /types                                      # ts 类型声明文件\n")])])]),s("h3",{attrs:{id:"构建"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构建"}},[t._v("#")]),t._v(" 构建")]),t._v(" "),s("p",[t._v("以 Runtime+Compiler 版本为例，是以 "),s("code",[t._v("src/platforms/web/entry-runtime-with-compiler.js")]),t._v(" 为入口开始构建的，通过注入的方式为特定环境添加特定的功能，如：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" mount "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("$mount\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 注入当前版本特定的")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 该函数中调用了 compiler")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("$mount")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("el"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" hydrating")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h2",{attrs:{id:"核心模块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#核心模块"}},[t._v("#")]),t._v(" 核心模块")]),t._v(" "),s("p",[t._v("我看的版本是 2.5.18-beta.0 版本的，但其实更好的方式是看早期版本，如 1.0 或者更早的，因为那时候是比较纯粹的，现在的版本会有许多折中可能不太适合阅读。")]),t._v(" "),s("p",[t._v("我将 Vue 的核心分为如下模块，在看代码时采取分块阅读的方式：")]),t._v(" "),s("ul",[s("li",[t._v("变化监测")]),t._v(" "),s("li",[t._v("模板编译")]),t._v(" "),s("li",[t._v("虚拟 DOM")])])])}),[],!1,null,null,null);e.default=n.exports}}]);